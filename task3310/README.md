Это укорачиватель Shortener, некий аналог укорачивателя
ссылок Google URL Shortener (https://goo.gl), но я расширю его функциональность и
сделаю консольным. Он будет сокращать не только ссылки, но и любые строки.
Мой Shortener - это класс, который может для любой строки вернуть некий
уникальный идентификатор и наоборот, по ранее полученному идентификатору
вернуть строку.

Два дополнительных требования к Shortener:
- для двух одинаковых строк должен возвращаться один и тот же идентификатор;
- он должен поддерживать столько строк, сколько значений может принимать long,
  именно этот тип будет использоваться для идентификатора.
  Первое требование очень сильно влияет на производительность, т.к. при получении
  идентификатора для новой строки мы должны проверить не обрабатывалась ли эта
  строка ранее, чтобы вернуть старый идентификатор.

<h3>План действий:</h3>
<ul style="list-style-type:none">
<li> 1.1. Объявить класс Shortener.</li>
<li>1.2. Добавить методы заглушки в объявленный класс:</li>
<ul style="list-style-type:none">
<li>1.2.1. Long getId(String string) - будет возвращать идентификатор id для заданной
строки.</li>
<li>1.2.2. String getString(Long id) - будет возвращать строку для заданного
идентификатора или null, если передан неверный идентификатор.</li>
</ul>
<li>1.3. Создать класс Solution с пустым методом main.</li>
<li>2.1. Добавить интерфейс StorageStrategy в пакет strategy.</li>
<li>2.2. Добавить в интерфейс следующие методы:</li>
<ul style="list-style-type:none">
<li>2.2.1. boolean containsKey(Long key) - должен вернуть true, если хранилище
содержит переданный ключ.</li>
<li>2.2.2. boolean containsValue(String value) - должен вернуть true, если хранилище
содержит переданное значение.</li>
<li>2.2.3. void put(Long key, String value) - добавить в хранилище новую пару ключ -
значение.</li>
<li>2.2.4. Long getKey(String value) - вернуть ключ для переданного значения.</li>
</ul>
<li>3.1. Добавить в класс Shortener поле Long lastId. Проинициализируй его нулем. Это поле будет
отвечать за последнее значение идентификатора, которое было использовано при добавлении новой строки в хранилище.</li>
<li>3.2. Добавить поле StorageStrategy storageStrategy в котором будет храниться стратегия хранения данных.</li>
<li>3.3. Добавить конструктор, который принимает StorageStrategy и инициализирует соответствующее поле класса.</li>
<li>3.4. Реализовать метод getId, он должен:</li>
<ul style="list-style-type:none">
<li>3.4.1. Проверить есть ли переданное значение в хранилище, если есть - вернуть его ключ.</li>
<li>3.4.2. Если преданного значения нет в хранилище, то:</li>
<ul style="list-style-type:none">
<li>3.4.2.1. Увеличить значение lastId на единицу;</li>
<li>3.4.2.2. Добавить в хранилище новую пару ключ-значение (новое значение lastId и переданную строку);</li>
<li>3.4.2.3. Вернуть новое значение lastId.</li>
</ul>
<li>3.5. Реализовать метод getString, он должен вернуть строку по заданному идентификатору (ключу).</li>
<li>3.6. Предусмотреть возможность вызова методов getId и getString из разных потоков добавив соответствующий модификатор к заголовкам методов.</li>
<li>4.1. Создать класс Helper.</li>
<ul style="list-style-type:none">
<li>4.1.1. Добавить в него статический публичный метод String generateRandomString(), который будет генерировать случайную строку. Воспользуйся для этого классами SecureRandom и BigInteger. Подсказка: гугли запрос "random string java". Строка может состоять из цифр и любой из 26 маленьких букв английского алфавита.</li>
<li>4.1.2. Добавить в класс статический метод printMessage(String message). Он должен выводить переданный текст в консоль. Весь дальнейший вывод в программе должен быть реализован через этот метод!</li>
</ul>
<li>4.2. Создать класс ExceptionHandler.</li>
<li>4.2.1. Добавить в него статический метод log(Exception e), который будет выводить краткое описание исключения.</li>
<li>5.1. Создать класс HashMapStorageStrategy, реализующий интерфейс StorageStrategy.</li>
<li>5.2. Добавить в класс поле HashMap с ключами типа Long, значениями - String и именем - data. В нем будут храниться наши данные.</li>
<li>5.3. Реализовать в классе все необходимые методы. Реализации методов должны использовать поле data.</li>
<li>6.1. Создать класс Solution, если ты не сделал это раньше.</li>
<li>6.2. Добавить в класс Solution реализации вспомогательных статических методов:</li>
<li style="list-style-type:none">
<li>6.2.1. Set типа Long getIds(Shortener shortener, Set типа String strings). Этот метод должен для переданного множества строк возвращать множество идентификаторов. Идентификатор для каждой отдельной строки нужно получить, используя shortener.</li>
<li>6.2.2. Set типа String getStrings(Shortener shortener, Set типа Long keys). Метод будет возвращать множество строк, которое соответствует переданному множеству идентификаторов.
При реальном использовании Shortener, задача получить из множества строк множество идентификаторов и наоборот скорее всего не встретится, это нужно исключительно для тестирования.</li>
<li>6.2.3. testStrategy(StorageStrategy strategy, long elementsNumber). Метод будет тестировать работу переданной стратегии на определенном количестве элементов elementsNumber. Реализация метода должна:</li>
<ul style="list-style-type:none">
<li>6.2.3.1. Выводить имя класса стратегии. Имя не должно включать имя пакета.</li>
<li>6.2.3.2. Генерировать тестовое множество строк, используя Helper и заданное количество элементов elementsNumber.</li>
<li>6.2.3.3. Создавать объект типа Shortener, используя переданную стратегию.</li>
<li>6.2.3.4. Замерять и выводить время необходимое для отработки метода getIds для заданной стратегии и заданного множества элементов. Время вывести в миллисекундах.</li>
<li>6.2.3.5. Замерять и выводить время необходимое для отработки метода getStrings для заданной стратегии и полученного в предыдущем пункте множества идентификаторов.</li>
<li>6.2.3.6. Сравнивать одинаковое ли содержимое множества строк, которое было сгенерировано и множества и было возвращено методом getStrings. Если множества одинаковы, то выведи "Тест пройден.", иначе "Тест не пройден.".</li>
</ul>
<li>6.2.4. Добавить метод main(). Внутри метода протестировать стратегию HashMapStorageStrategy с помощью 10000 элементов.</li>
<li>7.1. Создать свой аналог HashMap внутри пакета strategy. Это должен быть обычный, не вложенный, не generic класс.
В отличии от класса Node из HashMap, мой класс будет поддерживать только интерфейс Serializable и будет называться Entry.</li>
<li>7.2. Добавить в Entry следующие поля: Long key, String value, Entry next, int hash. Как видишь, наша реализация будет поддерживать только тип Long для ключа и только String для значения. Область видимости полей оставь по умолчанию.</li>
<li>7.3. Добавить и реализовать конструктор Entry(int hash, Long key, String value, Entry next).</li>
<li>7.4. Добавить и реализовать методы: Long getKey(), String getValue(), int hashCode(), boolean equals() и String toString(). Реализовывать остальные методы оригинального Entry не нужно, мы пишем упрощенную версию.</li>
<li>8.1. Добавить и реализовать класс OurHashMapStorageStrategy, 
используя класс Entry из предыдущей подзадачи. 
Класс OurHashMapStorageStrategy должен реализовывать интерфейс 
StorageStrategy. В классе должны быть следующие поля:</li>
<ul style="list-style-type:none">
<li>8.1.1. static final int DEFAULT_INITIAL_CAPACITY = 16;</li>
<li>8.1.2. static final float DEFAULT_LOAD_FACTOR = 0.75f;</li>
<li>8.1.3. Entry[] table = new Entry[DEFAULT_INITIAL_CAPACITY];</li>
<li>8.1.4. int size;</li>
<li>8.1.5. int threshold = (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</li>
<li>8.1.6. float loadFactor = DEFAULT_LOAD_FACTOR;</li>
</ul>
<li>8.2. Реализовать в классе следующие вспомогательные методы:</li>
<ul style="list-style-type:none">
<li>8.2.1. int hash(Long k)</li>
<li>8.2.2. int indexFor(int hash, int length)</li>
<li>8.2.3. Entry getEntry(Long key)</li>
<li>8.2.4. void resize(int newCapacity)</li>
<li>8.2.5. void transfer(Entry[] newTable)</li>
<li>8.2.6. void addEntry(int hash, Long key, String value, int bucketIndex)</li>
<li>8.2.7. void createEntry(int hash, Long key, String value, int bucketIndex)</li>
</ul>
<li>8.3. Добавить в класс публичные методы, которые требует интерфейс StorageStrategy.</li>
<li>9.1. Создать класс FileBucket в пакете strategy.</li>
<li>9.2. Добавить в класс поле Path path (путь к файлу).</li>
<li>9.3. Добавить в класс конструктор без параметров, он должен:</li>
<ul style="list-style-type:none">
<li>9.3.1. Инициализировать path временным файлом. Файл должен быть размещен в директории для временных файлов и иметь случайное имя.</li>
<li>9.3.2. Создавать новый файл, используя path. Если такой файл уже есть, то заменять его.</li>
<li>9.3.3. Обеспечивать удаление файла при выходе из программы.</li>
</ul>
9.4. Добавить в класс методы:
<ul style="list-style-type:none">
<li>9.4.1. public long getFileSize(), он должен возвращать размер файла на который указывает path.</li>
<li>9.4.2. public void putEntry(Entry entry) - должен сериализовывать переданный entry в файл. Учти, каждый entry может содержать еще один entry.</li>
<li>9.4.3. public Entry getEntry() - должен забирать entry из файла. Если файл имеет нулевой размер, вернуть null.</li>
<li>9.4.4.public void remove() - удалять файл на который указывает path.</li>
</ul>
<li>10.1. Создать и реализовать класс FileStorageStrategy, реализующий интерфейс StorageStrategy.</li>
<li>10.2. Использовать FileBucket в качестве ведер (класс должен содержать поле FileBucket[] table).</li>
<li>10.3. Работать аналогично тому, как это делает OurHashMapStorageStrategy, но удваивать количество ведер не когда количество элементов size станет больше какого-то порога, а когда размер одного из ведер (файлов) стал больше bucketSizeLimit.</li>
<ul style="list-style-type:none">
<li>10.3.1. Добавь в класс поле long bucketSizeLimit.</li>
<li>10.3.2. Проинициализируй его значением по умолчанию, например, 10000 байт.<li>
<li>10.3.3. Добавь сеттер и геттер для этого поля.</li>
</ul>
<li>10.4. При реализации метода resize(int newCapacity) проследи, чтобы уже не нужные файлы были удалены (вызови метод remove()) и проверь новую стратегию в методе main().</li>
<li>11.1. Создать класс OurHashBiMapStorageStrategy, реализующий интерфейс StorageStrategy.</li>
<li>11.2. Добавить в него два поля HashMap с ключами типа Long и значениями - String <b>k2v</b> и HashMap c ключами типа String и значениями - Long <b>v2k</b>.</li>
Первое будет хранить соответствие ключа и значения, а второе наоборот: значения и ключа.
<li>11.3. Реализовать методы интерфейса StorageStrategy, обеспечив максимальную скорость.</li>
<li>12.1. Скачать и подключить библиотеку guava</li>
<li>12.2. Реализовать стратегию HashBiMapStorageStrategy. Она должна:</li>
<ul style="list-style-type:none">
<li>12.2.1. Поддерживать интерфейс StorageStrategy.</li>
<li>12.2.2. Внутри иметь только одно поле data типа HashBiMap.</li>
</ul>
<li>13.1. Скачать и подключить Apache Commons Collections 4.0.</li>
<li>13.2. Реализовать стратегию DualHashBidiMapStorageStrategy. Она должна:</li>
<ul style="list-style-type:none">
<li>13.2.1. Поддерживать интерфейс StorageStrategy.</li>
<li>13.2.2. Внутри иметь только одно поле data с типом DualHashBidiMap.</li>
</ul>
<li>13.3. Можно проверить новую стратегию в методе main(). Запусти программу и сравни скорость работы шести стратегий.</li>
<li>14.1. Написать юнит-тест с помощью библиотеки Junit 4.13.</li>
<li>14.2. Добавить класс FunctionalTest в пакет tests. В этом классе мы проверим функциональность наших стратегий.</li>
<li>14.3. Добавить в класс FunctionalTest метод testStorage(Shortener shortener). Он должен:</li>
<ul style="list-style-type:none">
<li>14.3.1. Создавать три строки. Текст 1 и 3 строк должен быть одинаковым.</li>
<li>14.3.2. Получать и сохранять идентификаторы для всех трех строк с помощью shortener.</li>
<li>14.3.3. Проверять, что идентификатор для 2 строки не равен идентификатору для 1 и 3 строк.</li>
</ul>
<li>15.1. Создать класс SpeedTest в пакете tests.</li>
<li>15.2. Добавить в класс метод long getTimeToGetIds
(Shortener shortener, Set типа String strings, Set типа Long ids). 
Он должен возвращать время в миллисекундах необходимое для 
получения идентификаторов для всех строк из strings. 
Идентификаторы должны быть записаны в ids.</li>
<li>15.3. Добавить в класс метод long getTimeToGetStrings
(Shortener shortener, Set типа Long ids, Set типа String strings). 
Он должен возвращать время в миллисекундах необходимое для 
получения строк для всех идентификаторов из ids. 
Строки должны быть записаны в strings.</li>
<li>15.4. Добавь в класс SpeedTest тест testHashMapStorage(). 
Он должен:</li>
<ul style="list-style-type:none">
<li>15.4.1. Создавать два объекта типа Shortener, один на базе 
HashMapStorageStrategy, второй на базе HashBiMapStorageStrategy.
Назовем их shortener1 и shortener2.</li>
<li>15.4.2. Генерировать с помощью Helper 10000 строк и помещать 
их в сет со строками, назовем его origStrings.</li>
<li>15.4.3. Получать время получения идентификаторов для 
origStrings (вызывать метод getTimeToGetIds для shortener1, а 
затем для shortener2).</li>
<li>15.4.4. Проверять с помощью junit, что время, полученное 
в предыдущем пункте для shortener1 больше, чем для shortener2.</li>
<li>15.4.5. Получать время получения строк (вызывать метод 
getTimeToGetStrings для shortener1 и shortener2).</li>
<li>15.4.6. Проверять с помощью junit, что время, 
полученное в предыдущем пункте для shortener1 примерно равно 
времени для shortener2.</li>
</ul>
</ul>
</ul>
<h3>Достижения:</h3>

- Повторила паттерн Стратегия.
- Получила опыт работы с библиотекой Guava.
- Получила опыт работы с Apache Commons Collections.
- Попробовала писать тесты, используя Junit.
- Разобралась во внутренней организации HashMap

<h3>Что можно сделать ещё:</h3>

- Добавить стратегию, основанную на работе с базой данных (JDBC).
- Сделать веб сервис, который будет для любого url или строки возвращать идентификатор, а для идентификатора строку.
- Написать вариант HashMap с использованием двух потоков, где один поток будет отвечать за работу с элементами, а второй следить за количеством элементов. Когда количество элементов превысит порог threshold, второй поток должен увеличить размер table в 2 раза. При этом, первый поток ничего не должен знать о пороге.